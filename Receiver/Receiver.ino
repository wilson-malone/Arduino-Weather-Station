/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/be7c7702-0c02-4a58-9550-33627c4666e4 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float netpress;
  float netspeed;
  int netdirection;
  int nethumid;
  int nettemp;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <Wire.h>                           // Include the Arduino I2C library
#include <SPI.h>                            //Serial Peripheral interface. This is used for the radio
#include <RH_RF69.h>                        //Radiohead Library for the receiver
#include <SparkFun_Alphanumeric_Display.h>  //The 14 segment alphanumeric display library
#include <s7s.h>
#include <RHDatagram.h>


#define SERVER_ADDRESS 1 //Radio server address
#define MY_ADDRESS 2 // This device's address

#define RF69_FREQ 902.3  //915mhz for USA and Canada
#define POWER 6       // Radio power output dbm
#define RFM69_CS 4   // Radio pin for Chip Select
#define RFM69_INT 3  // radio pin for IRQ interrupt.
#define RFM69_RST 2  // Radio pin for radio reset
#define LED 8        // The blinky light LED so that we know that data is being received.

uint8_t transmit_counter = 0; //Defines the retry counter.
char *message[] = { "NO S", "O SI", " SIG", "SIGN", "IGNA", "GNAL", "NAL ", "AL N", "L NO", " NO " }; //No signal message
unsigned long radio_timer;
unsigned long blink_interval;
unsigned long standbytimer;
bool standby;
bool blink1;
bool messageRX;
bool LEDstatus;
uint8_t errcounter=0;
uint16_t cloudloop=0;

// Will be used with sprintf to create strings
char tempString[10];  
char pressString[10];
char humidString[10];
char speedString[10];
char directionString[10];

//Received data structure
struct TPHData {
  int16_t temperature = 9;
  int16_t pressure = 9999;
  int16_t humidity = 99;
  int16_t speed = 9;
  int16_t direction = 17;
}; TPHData Bundle;  // Make a variable for the structure above and call it 'Bundle'

s7s s7dis;  // calling an instance of the seven segment display

HT16K33 _14display; //14 Segment display object for the library functions


// initialize instance of the radio driver
RH_RF69 rf69(RFM69_CS, RFM69_INT);
RHDatagram rf69_manager(rf69, MY_ADDRESS);
#define CONFIG_GFSK (RH_RF69_DATAMODUL_DATAMODE_PACKET | RH_RF69_DATAMODUL_MODULATIONTYPE_FSK | RH_RF69_DATAMODUL_MODULATIONSHAPING_FSK_BT1_0)
#define CONFIG_MANCHESTER (RH_RF69_PACKETCONFIG1_PACKETFORMAT_VARIABLE | RH_RF69_PACKETCONFIG1_DCFREE_MANCHESTER | RH_RF69_PACKETCONFIG1_CRC_ON | RH_RF69_PACKETCONFIG1_ADDRESSFILTERING_NONE)

static const RH_RF69::ModemConfig Table = { CONFIG_GFSK, 0x01, 0x00, 0x08, 0x00, 0xe1, 0xe1, CONFIG_MANCHESTER};

//The displayed directions correspond to this list. Uncomment if using the 16 direction option.
//The wind direction sensor vane has two Norths 0x00 and 0x10 for some reason. It also transmits both 000 and 360 when
//in the 360 degree mode. I don't really understand why that's necessary, but this accomodates it.
//char *_direction_list[] = { "   N", " NNE", "  NE", " ENE", "   E", " ESE", "  SE", " SSE", "   S", " SSW", "  SW", " WSW", "   W", " WNW", "  NW", " NNW", "   N", "INIT", "FAIL", "STBY" };


void RadioTX() {
  uint8_t radiopacket[] = "ON";
  // Send a message to the server
  rf69_manager.sendto(radiopacket, sizeof(radiopacket), SERVER_ADDRESS);
  radio_timer = millis();
}

void RadioCopy(){
  uint8_t datalen = sizeof(Bundle);
  uint8_t from;
  if (rf69_manager.recvfrom((uint8_t *)&Bundle, &datalen, &from)) {
    Bundle.temperature = ntohs(Bundle.temperature);
    Bundle.pressure = ntohs(Bundle.pressure);
    Bundle.humidity = ntohs(Bundle.humidity);
    Bundle.speed = ntohs(Bundle.speed);
    Bundle.direction = ntohs(Bundle.direction);
    messageRX = true;
    if(!LEDstatus){blink1=true;}  // blink LED
    transmit_counter=0;
  }
}


void display_data(){
    //Call the 7 segment displays.
    //7 Segment displays need to have the strings formatted to display properly.
    sprintf(tempString, "%3dF", Bundle.temperature);
    sprintf(pressString, "%4d", Bundle.pressure);
    sprintf(humidString, "%3d-", Bundle.humidity);
    sprintf(speedString, "%4d", Bundle.speed);
    sprintf(directionString, "%4d", Bundle.direction);

    //_14display.print(_direction_list[Bundle.direction]);
    //Send data to 14 segment display.
    _14display.print(directionString);
    // Input string to send to 7 segment displays, the display address, and the decimal point configuration as a binary sequence.
    s7dis.Transmit(tempString, 0b00100000, 0x01);
    s7dis.Transmit(pressString, 0b00000010, 0x02);
    s7dis.Transmit(humidString, 0b00101000, 0x03);
    s7dis.Transmit(speedString, 0b00000100, 0x71);
}

void cloudUpdate(){
    nethumid = Bundle.humidity;
    netpress = Bundle.pressure;
    netpress /= 100;
    netspeed = Bundle.speed;
    netspeed /=10;
    nettemp = Bundle.temperature;
    netdirection = Bundle.direction;
}

//setup function

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(4);
  ArduinoCloud.printDebugInfo();
  
  Wire.begin();  // Initialize hardware I2C pins
  Serial.println("Wire I2C library begin");
    
  //Initializes the 14 segment display at its default address.
  if (_14display.begin(0x70) == false) {
    Serial.println("14 Segment display did not acknowledge! Freezing.");
  } else {
    Serial.println("Start 14 seg display");
  }

  //The 14 segment display does not rely on non-volatile memory for it's brightness setting, therefore it has to be set each startup.
  // if (_14display.setBrightness(1)) {
  //   Serial.println("Set 14 seg display brightness");
  // } else {
  //   Serial.println("14 seg display brightness failed");
  // }

   _14display.print("ON");

  // Clear the 7 segment displays before jumping into loop
  s7dis.clearDisplayI2C(0x01);
  s7dis.clearDisplayI2C(0x02);
  s7dis.clearDisplayI2C(0x03);
  s7dis.clearDisplayI2C(0x71);

  Serial.println("Clear 7 segment Displays");

  
  // s7dis.addressChange(0x71, 0x04);

  //Brightness is stored in non-volatile memory on the 7 segment displays, so it only needs to be called once.


  s7dis.setBrightness(0x01, 0xff);
  s7dis.setBrightness(0x02, 0xff);
  s7dis.setBrightness(0x03, 0xff);
  s7dis.setBrightness(0x71, 0xff);


  //Radio Initialization
  pinMode(RFM69_RST, OUTPUT);
  pinMode(LED, OUTPUT);
  digitalWrite(RFM69_RST, LOW);

  Serial.println("RFM69 Start");

  digitalWrite(RFM69_RST, HIGH);
  delay(10);
  digitalWrite(RFM69_RST, LOW);
  delay(10);

  Serial.println("Radio Reset");

  if (!rf69_manager.init()) {
    Serial.println("Datagram manager initialization failed");
  } else {
    Serial.println("Datagram Init OK");
  }

  if (!rf69.setFrequency(RF69_FREQ)) {
    Serial.println("setFrequency failed");
  } else {
    Serial.println("Frequency Set OK");
  }

  // If you are using a high power RF69 eg RFM69HW, you *must* set a Tx power with the
  // ishighpowermodule flag set like this:
  rf69.setTxPower(POWER, true);  // 2nd arg must be true for 69HCW
  Serial.print("Radio power set to: "); Serial.println(POWER);
  Serial.print("RFM69 radio @"); Serial.print((int)RF69_FREQ); Serial.println(" MHz");

  rf69.setModemRegisters(&Table);

  //End Radio Initialization

  Serial.println("Setup Complete");

  RadioTX();
  
  
}

void loop() {
  cloudloop++;
  if (cloudloop == 65535){
    ArduinoCloud.update();
  }
  if (millis() - radio_timer > 2000){
    RadioTX();
    transmit_counter++;
  }

  //Call the radio receive function.
  if (!rf69_manager.available()) {
    if(!standby && transmit_counter > 2){
      s7dis.clearDisplayI2C(0x01);
      s7dis.clearDisplayI2C(0x02);
      s7dis.clearDisplayI2C(0x03);
      s7dis.clearDisplayI2C(0x71);
      standby=true;
      messageRX=false;
    }  
  }else{
    RadioCopy();
    display_data();
    cloudUpdate();
  }

if (standby) {
    if (!messageRX && millis() - standbytimer > 1000) {
        _14display.print(message[errcounter]);
        errcounter++;
        standbytimer = millis();
        
        // Check if errcounter exceeds message array length
        if (errcounter > (sizeof(message) / sizeof(message[0]) - 1)) {
            errcounter = 0;
        }  
    }
    
    // Exit standby if a message is received
    if (messageRX == true) {
        standby = false;
        errcounter = 0;
    }
}
  
  if (!blink1 && LEDstatus && (millis() - blink_interval > 40)) {
    digitalWrite(LED, LOW);
    LEDstatus = false;
  }

  // Check for LED on state and reset the `blink1` trigger
  if (blink1 && !LEDstatus) {
    digitalWrite(LED, HIGH);
    blink1 = false;            // Reset the blink1 trigger after setting LED on
    LEDstatus = true;
    blink_interval = millis(); // Start the interval for timing the next toggle
  }

}

